{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.PowerGlitch = exports.mergeOptions = void 0;\n/**\n * Get best-looking default options for most elements for a given playMode.\n */\nconst getDefaultOptions = (playMode = 'always') => {\n  return {\n    playMode,\n    createContainers: true,\n    hideOverflow: false,\n    timing: playMode === 'always' ? {\n      duration: 2 * 1000,\n      iterations: Infinity\n    } : {\n      duration: 250,\n      iterations: 1\n    },\n    glitchTimeSpan: playMode === 'always' ? {\n      start: 0.5,\n      end: 0.7\n    } : {\n      start: 0,\n      end: 1\n    },\n    shake: {\n      velocity: 15,\n      amplitudeX: 0.2,\n      amplitudeY: 0.2\n    },\n    slice: playMode === 'click' ? {\n      count: 15,\n      velocity: 20,\n      minHeight: 0.02,\n      maxHeight: 0.15,\n      hueRotate: true\n    } : {\n      count: 6,\n      velocity: 15,\n      minHeight: 0.02,\n      maxHeight: 0.15,\n      hueRotate: true\n    },\n    pulse: false\n  };\n};\n/**\n * Glitch factor function, returns a value between 0 and 1 telling how much the animation should glitch at a given stepPct.\n */\nconst getGlitchFactor = (options, stepPct) => {\n  if (!options.glitchTimeSpan) {\n    return 1;\n  }\n  const glitchStart = options.glitchTimeSpan.start;\n  const glitchEnd = options.glitchTimeSpan.end;\n  if (stepPct < glitchStart || stepPct > glitchEnd) {\n    return 0;\n  }\n  const glitchPeak = glitchStart + (glitchEnd - glitchStart) / 2;\n  if (stepPct < glitchPeak) {\n    return (stepPct - glitchStart) / (glitchPeak - glitchStart);\n  } else {\n    return (glitchEnd - stepPct) / (glitchEnd - glitchPeak);\n  }\n};\n/**\n * Get a random value between -1 and 1, which biases towards the center if the animation should not glitch at the given `stepPct` moment.\n */\nconst getGlitchRandom = (options, stepPct) => {\n  return (Math.random() - .5) * 2 * getGlitchFactor(options, stepPct);\n};\n/**\n * Get a random rectangle values in % to glitch. Percent values are between 0 and 100. Returns the rectangle as a CSS polygon.\n * @param minHeight Minimum height of the rectangle in percent, between 0 and 1.\n * @param maxHeight Maximum height of the rectangle in percent, between 0 and 1.\n * @param minWidth Minimum width of the rectangle in percent, between 0 and 1.\n * @param maxWidth Maximum width of the rectangle in percent, between 0 and 1.\n */\nconst getRandomRectanglePolygonCss = ({\n  minHeight,\n  maxHeight,\n  minWidth,\n  maxWidth\n}) => {\n  const height = Math.floor(Math.random() * ((maxHeight - minHeight) * 100 + 1)) + minHeight * 100;\n  const width = Math.floor(Math.random() * ((maxWidth - minWidth) * 100 + 1)) + minWidth * 100;\n  // Put this rectangle somewhere in the container so that it does not go out of the screen.\n  const top = Math.floor(Math.random() * (100 - height));\n  const left = Math.floor(Math.random() * (100 - width));\n  const topRight = `${left + width}% ${top}%`;\n  const bottomRight = `${left + width}% ${top + height}%`;\n  const bottomLeft = `${left}% ${top + height}%`;\n  const topLeft = `${left}% ${top}%`;\n  return `polygon(${topRight},${bottomRight},${bottomLeft},${topLeft})`;\n};\n/**\n * Generate a slice layer, slicing part of the element and moving it somwhere else.\n * @param options\n */\nconst generateGlitchSliceLayer = options => {\n  const stepCount = Math.floor(options.slice.velocity * options.timing.duration / 1000) + 1;\n  const steps = [];\n  for (let index = 0; index < stepCount; ++index) {\n    if (getGlitchFactor(options, index / stepCount) === 0) {\n      steps.push({\n        opacity: '0',\n        transform: 'none',\n        clipPath: 'unset'\n      });\n      continue;\n    }\n    const translateX = getGlitchRandom(options, index / stepCount) * 30;\n    const styles = {\n      opacity: '1',\n      transform: `translate3d(${translateX}%,0,0)`,\n      clipPath: getRandomRectanglePolygonCss({\n        minHeight: options.slice.minHeight,\n        maxHeight: options.slice.maxHeight,\n        minWidth: 1,\n        maxWidth: 1\n      })\n    };\n    if (options.slice.hueRotate) {\n      styles.filter = `hue-rotate(${Math.floor(getGlitchRandom(options, index / stepCount) * 360)}deg)`;\n    }\n    steps.push(styles);\n  }\n  return {\n    steps,\n    timing: Object.assign({\n      easing: `steps(${stepCount},jump-start)`\n    }, options.timing)\n  };\n};\n/**\n * Generate a pulse layer, a single transparent and growing layer.\n * @param options\n */\nconst generateGlitchPulseLayer = options => {\n  return !options.pulse ? null : {\n    steps: [{\n      transform: 'scale(1)',\n      opacity: '1'\n    }, {\n      transform: `scale(${options.pulse.scale})`,\n      opacity: '0'\n    }],\n    timing: Object.assign(Object.assign({}, options.timing), {\n      delay: (options.glitchTimeSpan ? options.glitchTimeSpan.start : 0) * options.timing.duration,\n      easing: 'ease-in-out'\n    })\n  };\n};\n/**\n * Generate the base layer, which may or may not shake depending on the options.\n * @param options\n */\nconst generateBaseLayer = options => {\n  if (!options.shake) {\n    return {\n      steps: [],\n      timing: {}\n    };\n  }\n  const stepCount = Math.floor(options.shake.velocity * options.timing.duration / 1000) + 1;\n  const steps = [];\n  for (let index = 0; index < stepCount; ++index) {\n    const translateX = getGlitchRandom(options, index / stepCount) * options.shake.amplitudeX * 100;\n    const translateY = getGlitchRandom(options, index / stepCount) * options.shake.amplitudeY * 100;\n    steps.push({\n      transform: `translate3d(${translateX}%,${translateY}%,0)`\n    });\n  }\n  return {\n    steps,\n    timing: Object.assign({\n      easing: `steps(${stepCount},jump-start)`\n    }, options.timing)\n  };\n};\n/**\n * Generate the layers that deterministically define a glitch animation for the specified options.\n */\nconst generateLayers = options => [generateBaseLayer(options), generateGlitchPulseLayer(options), ...Array.from({\n  length: options.slice.count\n}).map(() => generateGlitchSliceLayer(options))].filter(entry => entry !== null);\n/**\n* Performs a deep merge of option objects and returns new object. Does not modify\n* objects (immutable) and will ignore arrays.\n* @param objects - Objects to merge\n* @returns New object with merged key/values\n*/\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nconst mergeOptions = (...objects) => {\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  const isObject = obj => obj && typeof obj === 'object';\n  return objects.reduce((prev, obj) => {\n    Object.keys(obj).forEach(key => {\n      if (isObject(prev[key]) && isObject(obj[key])) {\n        prev[key] = (0, exports.mergeOptions)(prev[key], obj[key]);\n      } else if (obj[key] !== undefined) {\n        prev[key] = obj[key];\n      }\n    });\n    return prev;\n  }, {});\n};\nexports.mergeOptions = mergeOptions;\n/**\n * Prepare the DOM to set up the glitch effect.\n * @remarks\n * Depending on the element state:\n *  - Whether it was glitched before or not,\n *  - Whether current element display attributes\n *  - Whether options.createContainers is true/false\n * The top-level container and layer containers might be different objects and might need to be created.\n * @param element\n * @param options\n * @returns\n */\nconst prepareGlitchElement = (element, options) => {\n  var _a, _b;\n  // If not creating the containers\n  if (!options.createContainers) {\n    return {\n      container: element,\n      layersContainer: element,\n      glitched: element.firstElementChild\n    };\n  }\n  // If first glitch\n  if (!element.dataset.glitched) {\n    // Setup the layer container using grid to stack elements\n    const layersContainer = document.createElement('div');\n    // If current element is an inline element\n    const container = document.createElement('div');\n    if (getComputedStyle(element).getPropertyValue('display').match(/^inline/)) {\n      container.style.display = 'inline-block';\n    }\n    // Add the layers container to the global container\n    container.appendChild(layersContainer);\n    // Replace element with the new container\n    (_a = element.parentElement) === null || _a === void 0 ? void 0 : _a.insertBefore(container, element);\n    layersContainer.prepend(element);\n    return {\n      container,\n      layersContainer,\n      glitched: element\n    };\n  }\n  // Not first glitch, with createContainers=true\n  const layersContainer = element.parentElement;\n  const container = (_b = element.parentElement) === null || _b === void 0 ? void 0 : _b.parentElement;\n  // Remove all glitch layers but keep the first one (which is the original element)\n  while (layersContainer.children.length > 1) {\n    layersContainer.removeChild(layersContainer.children[1]);\n  }\n  // Cancel the animation on the first layer\n  layersContainer.firstElementChild.getAnimations().forEach(animation => animation.cancel());\n  return {\n    container,\n    layersContainer,\n    glitched: element\n  };\n};\n/**\n * Given a set of computed layers and user options, glitch a given element\n * @param element\n * @param layers\n * @param options\n */\nconst glitchElement = (element, layers, options) => {\n  const {\n    glitched,\n    container,\n    layersContainer\n  } = prepareGlitchElement(element, options);\n  // Force grid display on the layer container\n  layersContainer.style.display = 'grid';\n  // Overflow\n  if (options.hideOverflow) {\n    container.style.overflow = 'hidden';\n  }\n  // If setting HTML manually\n  if (options.html) {\n    glitched.innerHTML = options.html;\n  }\n  // Stack original element too (it is used as the base shaking layer)\n  glitched.style.gridArea = '1/1/-1/-1';\n  // Base layer\n  const baseLayer = glitched.cloneNode(true);\n  // Stack this layer\n  baseLayer.style.gridArea = '1/1/-1/-1';\n  baseLayer.style.userSelect = 'none';\n  baseLayer.style.pointerEvents = 'none';\n  baseLayer.style.opacity = '0';\n  for (let i = 0; i < layers.length - 1; ++i) {\n    const layerDiv = baseLayer.cloneNode(true);\n    layersContainer.appendChild(layerDiv);\n  }\n  // Glitch control functions\n  const startGlitch = () => {\n    layers.forEach((layer, i) => {\n      layersContainer.children[i].animate(layer.steps, layer.timing);\n    });\n  };\n  const stopGlitch = () => {\n    layers.forEach((_, i) => {\n      layersContainer.children[i].getAnimations().forEach(animation => {\n        animation.cancel();\n      });\n    });\n  };\n  // Depending on the selected play mode, orchestrate when to start/stop the glitch\n  container.onmouseenter = null;\n  container.onmouseleave = null;\n  container.onclick = null;\n  switch (options.playMode) {\n    case 'always':\n      startGlitch();\n      break;\n    case 'hover':\n      container.onmouseenter = startGlitch;\n      container.onmouseleave = stopGlitch;\n      break;\n    case 'click':\n      container.onclick = () => {\n        stopGlitch();\n        startGlitch();\n      };\n      break;\n  }\n  // Mark the glitched element as glitched for next round\n  element.dataset.glitched = '1';\n  return {\n    container,\n    startGlitch,\n    stopGlitch\n  };\n};\n/**\n * Make a single element glitch.\n * @param elOrSelector What to glitch. Can be a query selector, a list of HTMLElement, an HTMLElement or a NodeList.\n * @param userOptions Optional glitch customization options.\n */\nconst glitch = (elOrSelector = '.powerglitch', userOptions = {}) => {\n  // Fix options with defaults\n  const options = (0, exports.mergeOptions)(getDefaultOptions(userOptions.playMode), userOptions);\n  // Find elements to glitch\n  let elements = [];\n  if (typeof elOrSelector === 'string') {\n    elements = Array.from(document.querySelectorAll(elOrSelector));\n  } else if (elOrSelector instanceof NodeList) {\n    elements = Array.from(elOrSelector);\n  } else if (Array.isArray(elOrSelector)) {\n    elements = elOrSelector;\n  } else if (elOrSelector instanceof HTMLElement) {\n    elements = [elOrSelector];\n  }\n  // Generate all animation layers\n  const layers = generateLayers(options);\n  // Animate each div element\n  const entries = elements.map(element => glitchElement(element, layers, options));\n  // Return list of containers and glitch control functions\n  return {\n    containers: entries.map(entry => entry.container),\n    startGlitch: () => entries.forEach(entry => entry.startGlitch()),\n    stopGlitch: () => entries.forEach(entry => entry.stopGlitch())\n  };\n};\nexports.PowerGlitch = {\n  glitch,\n  generateLayers,\n  getDefaultOptions\n};","map":{"version":3,"names":["Object","defineProperty","exports","value","PowerGlitch","mergeOptions","getDefaultOptions","playMode","createContainers","hideOverflow","timing","duration","iterations","Infinity","glitchTimeSpan","start","end","shake","velocity","amplitudeX","amplitudeY","slice","count","minHeight","maxHeight","hueRotate","pulse","getGlitchFactor","options","stepPct","glitchStart","glitchEnd","glitchPeak","getGlitchRandom","Math","random","getRandomRectanglePolygonCss","minWidth","maxWidth","height","floor","width","top","left","topRight","bottomRight","bottomLeft","topLeft","generateGlitchSliceLayer","stepCount","steps","index","push","opacity","transform","clipPath","translateX","styles","filter","assign","easing","generateGlitchPulseLayer","scale","delay","generateBaseLayer","translateY","generateLayers","Array","from","length","map","entry","objects","isObject","obj","reduce","prev","keys","forEach","key","undefined","prepareGlitchElement","element","_a","_b","container","layersContainer","glitched","firstElementChild","dataset","document","createElement","getComputedStyle","getPropertyValue","match","style","display","appendChild","parentElement","insertBefore","prepend","children","removeChild","getAnimations","animation","cancel","glitchElement","layers","overflow","html","innerHTML","gridArea","baseLayer","cloneNode","userSelect","pointerEvents","i","layerDiv","startGlitch","layer","animate","stopGlitch","_","onmouseenter","onmouseleave","onclick","glitch","elOrSelector","userOptions","elements","querySelectorAll","NodeList","isArray","HTMLElement","entries","containers"],"sources":["D:/FormationOpen/projects/react-portfolio/node_modules/powerglitch/lib/src/index.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.PowerGlitch = exports.mergeOptions = void 0;\n/**\n * Get best-looking default options for most elements for a given playMode.\n */\nconst getDefaultOptions = (playMode = 'always') => {\n    return {\n        playMode,\n        createContainers: true,\n        hideOverflow: false,\n        timing: playMode === 'always' ? { duration: 2 * 1000, iterations: Infinity } : { duration: 250, iterations: 1 },\n        glitchTimeSpan: playMode === 'always' ? { start: 0.5, end: 0.7 } : { start: 0, end: 1, },\n        shake: {\n            velocity: 15,\n            amplitudeX: 0.2,\n            amplitudeY: 0.2,\n        },\n        slice: playMode === 'click' ? {\n            count: 15,\n            velocity: 20,\n            minHeight: 0.02,\n            maxHeight: 0.15,\n            hueRotate: true,\n        } : {\n            count: 6,\n            velocity: 15,\n            minHeight: 0.02,\n            maxHeight: 0.15,\n            hueRotate: true,\n        },\n        pulse: false,\n    };\n};\n/**\n * Glitch factor function, returns a value between 0 and 1 telling how much the animation should glitch at a given stepPct.\n */\nconst getGlitchFactor = (options, stepPct) => {\n    if (!options.glitchTimeSpan) {\n        return 1;\n    }\n    const glitchStart = options.glitchTimeSpan.start;\n    const glitchEnd = options.glitchTimeSpan.end;\n    if (stepPct < glitchStart || stepPct > glitchEnd) {\n        return 0;\n    }\n    const glitchPeak = glitchStart + (glitchEnd - glitchStart) / 2;\n    if (stepPct < glitchPeak) {\n        return (stepPct - glitchStart) / (glitchPeak - glitchStart);\n    }\n    else {\n        return (glitchEnd - stepPct) / (glitchEnd - glitchPeak);\n    }\n};\n/**\n * Get a random value between -1 and 1, which biases towards the center if the animation should not glitch at the given `stepPct` moment.\n */\nconst getGlitchRandom = (options, stepPct) => {\n    return (Math.random() - .5) * 2 * getGlitchFactor(options, stepPct);\n};\n/**\n * Get a random rectangle values in % to glitch. Percent values are between 0 and 100. Returns the rectangle as a CSS polygon.\n * @param minHeight Minimum height of the rectangle in percent, between 0 and 1.\n * @param maxHeight Maximum height of the rectangle in percent, between 0 and 1.\n * @param minWidth Minimum width of the rectangle in percent, between 0 and 1.\n * @param maxWidth Maximum width of the rectangle in percent, between 0 and 1.\n */\nconst getRandomRectanglePolygonCss = ({ minHeight, maxHeight, minWidth, maxWidth }) => {\n    const height = Math.floor(Math.random() * ((maxHeight - minHeight) * 100 + 1)) + minHeight * 100;\n    const width = Math.floor(Math.random() * ((maxWidth - minWidth) * 100 + 1)) + minWidth * 100;\n    // Put this rectangle somewhere in the container so that it does not go out of the screen.\n    const top = Math.floor(Math.random() * (100 - height));\n    const left = Math.floor(Math.random() * (100 - width));\n    const topRight = `${left + width}% ${top}%`;\n    const bottomRight = `${left + width}% ${top + height}%`;\n    const bottomLeft = `${left}% ${top + height}%`;\n    const topLeft = `${left}% ${top}%`;\n    return `polygon(${topRight},${bottomRight},${bottomLeft},${topLeft})`;\n};\n/**\n * Generate a slice layer, slicing part of the element and moving it somwhere else.\n * @param options\n */\nconst generateGlitchSliceLayer = (options) => {\n    const stepCount = Math.floor(options.slice.velocity * options.timing.duration / 1000) + 1;\n    const steps = [];\n    for (let index = 0; index < stepCount; ++index) {\n        if (getGlitchFactor(options, index / stepCount) === 0) {\n            steps.push({\n                opacity: '0',\n                transform: 'none',\n                clipPath: 'unset',\n            });\n            continue;\n        }\n        const translateX = getGlitchRandom(options, index / stepCount) * 30;\n        const styles = {\n            opacity: '1',\n            transform: `translate3d(${translateX}%,0,0)`,\n            clipPath: getRandomRectanglePolygonCss({ minHeight: options.slice.minHeight, maxHeight: options.slice.maxHeight, minWidth: 1, maxWidth: 1 }),\n        };\n        if (options.slice.hueRotate) {\n            styles.filter = `hue-rotate(${Math.floor(getGlitchRandom(options, index / stepCount) * 360)}deg)`;\n        }\n        steps.push(styles);\n    }\n    return {\n        steps,\n        timing: Object.assign({ easing: `steps(${stepCount},jump-start)` }, options.timing),\n    };\n};\n/**\n * Generate a pulse layer, a single transparent and growing layer.\n * @param options\n */\nconst generateGlitchPulseLayer = (options) => {\n    return !options.pulse ? null : {\n        steps: [\n            { transform: 'scale(1)', opacity: '1', },\n            { transform: `scale(${options.pulse.scale})`, opacity: '0', },\n        ],\n        timing: Object.assign(Object.assign({}, options.timing), { delay: (options.glitchTimeSpan ? options.glitchTimeSpan.start : 0) * options.timing.duration, easing: 'ease-in-out' }),\n    };\n};\n/**\n * Generate the base layer, which may or may not shake depending on the options.\n * @param options\n */\nconst generateBaseLayer = (options) => {\n    if (!options.shake) {\n        return { steps: [], timing: {} };\n    }\n    const stepCount = Math.floor(options.shake.velocity * options.timing.duration / 1000) + 1;\n    const steps = [];\n    for (let index = 0; index < stepCount; ++index) {\n        const translateX = getGlitchRandom(options, index / stepCount) * options.shake.amplitudeX * 100;\n        const translateY = getGlitchRandom(options, index / stepCount) * options.shake.amplitudeY * 100;\n        steps.push({\n            transform: `translate3d(${translateX}%,${translateY}%,0)`,\n        });\n    }\n    return {\n        steps,\n        timing: Object.assign({ easing: `steps(${stepCount},jump-start)` }, options.timing),\n    };\n};\n/**\n * Generate the layers that deterministically define a glitch animation for the specified options.\n */\nconst generateLayers = (options) => [\n    generateBaseLayer(options),\n    generateGlitchPulseLayer(options),\n    ...Array.from({ length: options.slice.count }).map(() => generateGlitchSliceLayer(options)),\n].filter(entry => entry !== null);\n/**\n* Performs a deep merge of option objects and returns new object. Does not modify\n* objects (immutable) and will ignore arrays.\n* @param objects - Objects to merge\n* @returns New object with merged key/values\n*/\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nconst mergeOptions = (...objects) => {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    const isObject = (obj) => obj && typeof obj === 'object';\n    return objects.reduce((prev, obj) => {\n        Object.keys(obj)\n            .forEach(key => {\n            if (isObject(prev[key]) && isObject(obj[key])) {\n                prev[key] = (0, exports.mergeOptions)(prev[key], obj[key]);\n            }\n            else if (obj[key] !== undefined) {\n                prev[key] = obj[key];\n            }\n        });\n        return prev;\n    }, {});\n};\nexports.mergeOptions = mergeOptions;\n/**\n * Prepare the DOM to set up the glitch effect.\n * @remarks\n * Depending on the element state:\n *  - Whether it was glitched before or not,\n *  - Whether current element display attributes\n *  - Whether options.createContainers is true/false\n * The top-level container and layer containers might be different objects and might need to be created.\n * @param element\n * @param options\n * @returns\n */\nconst prepareGlitchElement = (element, options) => {\n    var _a, _b;\n    // If not creating the containers\n    if (!options.createContainers) {\n        return {\n            container: element,\n            layersContainer: element,\n            glitched: element.firstElementChild,\n        };\n    }\n    // If first glitch\n    if (!element.dataset.glitched) {\n        // Setup the layer container using grid to stack elements\n        const layersContainer = document.createElement('div');\n        // If current element is an inline element\n        const container = document.createElement('div');\n        if (getComputedStyle(element).getPropertyValue('display').match(/^inline/)) {\n            container.style.display = 'inline-block';\n        }\n        // Add the layers container to the global container\n        container.appendChild(layersContainer);\n        // Replace element with the new container\n        (_a = element.parentElement) === null || _a === void 0 ? void 0 : _a.insertBefore(container, element);\n        layersContainer.prepend(element);\n        return {\n            container,\n            layersContainer,\n            glitched: element,\n        };\n    }\n    // Not first glitch, with createContainers=true\n    const layersContainer = element.parentElement;\n    const container = (_b = element.parentElement) === null || _b === void 0 ? void 0 : _b.parentElement;\n    // Remove all glitch layers but keep the first one (which is the original element)\n    while (layersContainer.children.length > 1) {\n        layersContainer.removeChild(layersContainer.children[1]);\n    }\n    // Cancel the animation on the first layer\n    layersContainer.firstElementChild.getAnimations().forEach(animation => animation.cancel());\n    return {\n        container,\n        layersContainer,\n        glitched: element,\n    };\n};\n/**\n * Given a set of computed layers and user options, glitch a given element\n * @param element\n * @param layers\n * @param options\n */\nconst glitchElement = (element, layers, options) => {\n    const { glitched, container, layersContainer } = prepareGlitchElement(element, options);\n    // Force grid display on the layer container\n    layersContainer.style.display = 'grid';\n    // Overflow\n    if (options.hideOverflow) {\n        container.style.overflow = 'hidden';\n    }\n    // If setting HTML manually\n    if (options.html) {\n        glitched.innerHTML = options.html;\n    }\n    // Stack original element too (it is used as the base shaking layer)\n    glitched.style.gridArea = '1/1/-1/-1';\n    // Base layer\n    const baseLayer = glitched.cloneNode(true);\n    // Stack this layer\n    baseLayer.style.gridArea = '1/1/-1/-1';\n    baseLayer.style.userSelect = 'none';\n    baseLayer.style.pointerEvents = 'none';\n    baseLayer.style.opacity = '0';\n    for (let i = 0; i < layers.length - 1; ++i) {\n        const layerDiv = baseLayer.cloneNode(true);\n        layersContainer.appendChild(layerDiv);\n    }\n    // Glitch control functions\n    const startGlitch = () => {\n        layers.forEach((layer, i) => {\n            layersContainer\n                .children[i]\n                .animate(layer.steps, layer.timing);\n        });\n    };\n    const stopGlitch = () => {\n        layers.forEach((_, i) => {\n            layersContainer\n                .children[i]\n                .getAnimations()\n                .forEach(animation => {\n                animation.cancel();\n            });\n        });\n    };\n    // Depending on the selected play mode, orchestrate when to start/stop the glitch\n    container.onmouseenter = null;\n    container.onmouseleave = null;\n    container.onclick = null;\n    switch (options.playMode) {\n        case 'always':\n            startGlitch();\n            break;\n        case 'hover':\n            container.onmouseenter = startGlitch;\n            container.onmouseleave = stopGlitch;\n            break;\n        case 'click':\n            container.onclick = () => { stopGlitch(); startGlitch(); };\n            break;\n    }\n    // Mark the glitched element as glitched for next round\n    element.dataset.glitched = '1';\n    return { container, startGlitch, stopGlitch };\n};\n/**\n * Make a single element glitch.\n * @param elOrSelector What to glitch. Can be a query selector, a list of HTMLElement, an HTMLElement or a NodeList.\n * @param userOptions Optional glitch customization options.\n */\nconst glitch = (elOrSelector = '.powerglitch', userOptions = {}) => {\n    // Fix options with defaults\n    const options = (0, exports.mergeOptions)(getDefaultOptions(userOptions.playMode), userOptions);\n    // Find elements to glitch\n    let elements = [];\n    if (typeof elOrSelector === 'string') {\n        elements = Array.from(document.querySelectorAll(elOrSelector));\n    }\n    else if (elOrSelector instanceof NodeList) {\n        elements = Array.from(elOrSelector);\n    }\n    else if (Array.isArray(elOrSelector)) {\n        elements = elOrSelector;\n    }\n    else if (elOrSelector instanceof HTMLElement) {\n        elements = [elOrSelector];\n    }\n    // Generate all animation layers\n    const layers = generateLayers(options);\n    // Animate each div element\n    const entries = elements.map(element => glitchElement(element, layers, options));\n    // Return list of containers and glitch control functions\n    return {\n        containers: entries.map(entry => entry.container),\n        startGlitch: () => entries.forEach(entry => entry.startGlitch()),\n        stopGlitch: () => entries.forEach(entry => entry.stopGlitch()),\n    };\n};\nexports.PowerGlitch = {\n    glitch,\n    generateLayers,\n    getDefaultOptions,\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}